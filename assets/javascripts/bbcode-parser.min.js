(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.bbcodeParser = {}));
})(this, (function (exports) { 'use strict';

    /* eslint-disable indent */ const isTagNode$1 = (el)=>typeof el === 'object' && !!el.tag;
    function process(tags, tree, core, options) {
        tree.walk((node)=>isTagNode$1(node) && tags[node.tag] ? tags[node.tag](node, core, options) : node);
    }
    /**
     * Creates preset for @bbob/core
     * @param defTags {Object}
     * @param processor {Function} a processor function of tree
     * @returns {function(*=): function(*=, *=): void}
     */ function createPreset(defTags, processor = process) {
        const presetFactory = (opts = {})=>{
            presetFactory.options = Object.assign(presetFactory.options || {}, opts);
            const presetExecutor = (tree, core)=>processor(defTags, tree, core, presetFactory.options);
            presetExecutor.options = presetFactory.options;
            return presetExecutor;
        };
        presetFactory.extend = (callback)=>createPreset(callback(defTags, presetFactory.options), processor);
        return presetFactory;
    }

    const toNode = (tag, attrs, content) => ({
      tag,
      attrs,
      content,
    });

    /**
     * Preprocess attributes of a node to either combine all values into a single default value
     * or return a keyed attribute list
     * @param {any} attrs object of bbcode node attrs
     * @param {string[]} predefinedKeys array of predefined keys to be captured
     * @returns processed attributes
     */
    const preprocessAttr = (attrs) => {
      const keys = Object.keys(attrs).join(" ");
      const vals = Object.values(attrs).join(" ");
      if (keys === vals) {
        return {
          _default: vals,
        };
      } else {
        return attrs;
      }
    };

    /**
    * @file Adds [left], [center], and [right] to bbcode
    * @example [center]content[/center]
    */
    const alignment = {
        left: (node) => toNode('div', { class: 'bb-left' }, node.content),
        center: (node) => toNode('div', { class: 'bb-center' }, node.content),
        right: (node) => toNode('div', { class: 'bb-right' }, node.content)
    };

    const bg = (node) => {
      const color = preprocessAttr(node.attrs)._default;
      return toNode(
        "div",
        {
          style: `background-color: ${color};`,
          class: "bb-background",
        },
        node.content
      );
    };

    const border = (node) => {
      const val = preprocessAttr(node.attrs)._default;
      return toNode(
        "div",
        {
          style: `border: ${val};`,
          class: "bb-border",
        },
        node.content
      );
    };

    const check = (node) => {
        const attrs = preprocessAttr(node.attrs)._default || "dot";
        return toNode("div",  { class: `bb-check`, "data-type": attrs },  node.content );
    };

    const color = (node) => {
      const inputColor = preprocessAttr(node.attrs)._default || "";
      if (inputColor.trim() === "") {
        return node.content;
      }
      return toNode("span", { style: `color: ${inputColor}` }, node.content);
    };

    const divide = (node) => {
      const type = (preprocessAttr(node.attrs)._default || "").toLowerCase();
      return toNode(
        "span",
        {
          class: "bb-divide",
          "data-type": type,
        },
        node.content
      );
    };

    const WEB_FONTS = [
      "arial",
      "book antiqua",
      "courier new",
      "georgia",
      "tahoma",
      "times new roman",
      "trebuchet ms",
      "verdana",
    ];
    const VALID_FONT_STYLES = {
      thin: "100",
      extralight: "200",
      light: "300",
      regular: "400",
      medium: "500",
      semibold: "600",
      bold: "700",
      extrabold: "800",
      black: "900",
    };
    // registered axis tags https://learn.microsoft.com/en-us/typography/opentype/spec/dvaraxisreg#registered-axis-tags
    const REGISTERED_AXIS = ["ital", "opsz", "slnt", "wdth", "wght"];

    const AXES_REGEX =
      /(?<named_weight>[a-zA-Z]*)?\s?(?<weight>[0-9]*)?\s?(?<italic>italic)?/;

    const axesParser = (attrs) => {
      let axes = {
        ital: 0,
        wght: 400,
      };

      if (attrs?.style) {
        // user just copy pasted the name of the style on the google font site, probably
        const style = attrs.style.trim().toLowerCase();
        const matches = AXES_REGEX.exec(style).groups || {};
        if (matches?.italic) {
          axes.ital = 1;
        }

        const weight = matches.weight;
        if (weight && weight >= 0 && weight <= 900) {
          axes.wght = weight;
        } else if (
          Object.keys(VALID_FONT_STYLES).includes(matches.named_weight || "")
        ) {
          axes.wght = VALID_FONT_STYLES[matches.named_weight];
        }

        axes = {
          ...axes,
          ...Object.fromEntries(
            Object.entries(attrs).filter(([key]) => REGISTERED_AXIS.includes(key))
          ),
        };
      }
      return axes;
    };

    /**
     * Create google font api url
     * @param {string} family name of font
     * @param {object<string, string>} axes custom font axes
     */
    const googleFontApiBuild = (family, axes) => {
      family = family.replaceAll(" ", "+");
      // google fonts requires axes names to be in alphabetical order
      axes = Object.keys(axes)
        .sort()
        .reduce((obj, key) => {
          obj[key] = axes[key];
          return obj;
        }, {});
      const axesList =
        Object.keys(axes).join(",") + "@" + Object.values(axes).join(",");
      return "https://fonts.googleapis.com/css2?family=" + family + ":" + axesList;
    };

    const font = (node, options) => {
      const attrs = preprocessAttr(node.attrs);
      const fontFamily = attrs?._default || attrs.family || attrs.name;
      if (fontFamily.trim() === "") {
        return node.content;
      }
      if (WEB_FONTS.includes(fontFamily.trim().toLowerCase())) {
        return toNode(
          "span",
          { style: "font-family: " + fontFamily },
          node.content
        );
      }

      const axes = axesParser(attrs);
      const url = googleFontApiBuild(fontFamily, axes);
      options.data.fonts.add(url);

      const italic = axes.ital === 1 ? "italic" : "normal";

      const custom = Object.entries(axes).filter(
        ([key]) => key !== "wght" && key !== "ital"
      );
      let fontVar = "";
      if (custom.length) {
        fontVar =
          "font-variation-settings: " +
          custom.map(([key, val]) => `'${key}' ${val}`).join(", ") +
          ";";
      }

      return toNode(
        "span",
        {
          style: `font-family: ${fontFamily}; font-weight: ${axes.wght}; font-style: ${italic}; ${fontVar}`,
          "data-font": url,
        },
        node.content
      );
    };

    /**
    * @file Adds [highlight] to bbcode
    * @example [highlight]content[/highlight]
    */
    const highlight = (node) => {
        return toNode('span', { class: 'bb-highlight' }, node.content);
    };

    /**
     * @file Adds [justify] to bbcode
     * @example [justify]content[/justify]
     */
    const justify = (node) => {
      return toNode("div", { class: "bb-justify" }, node.content);
    };

    /**
     * @file Adds [mail] to bbcode
     * @param {string} [type="send"] Denotes type of mail either send or receive
     * @param {string} [person="Unknown"] Denotes the person in the To/From field
     * @param {string} [subject="Empty"] Denotes the subject line of the email
     * @example [mail type="send" person="John Doe" subject="Hello World"]content[/mail]
     */

    const parseEmailContent = (content) => {
      return toNode("div", { class: "bb-email-content" }, content);
    };

    const parseEmailSubject = (subject) => {
      return toNode("div", { class: "bb-email-subject" }, subject);
    };

    const parseEmailPerson = (person) => {
      return toNode("div", { class: "bb-email-address" }, person);
    };

    const emailHeader = toNode("div", { class: "bb-email-header" }, "");
    const emailFooter = toNode(
      "div",
      { class: "bb-email-footer" },
      toNode("div", { class: "bb-email-button" }, "")
    );

    const mail = (node) => {
      const attributes = preprocessAttr(node.attrs);
      let mailAttr = {
        mailOption: (attributes.type || "send").toLowerCase(),
        person: attributes.person || "Unknown",
        subject: attributes.subject || "Empty",
      };

      return toNode(
        "div",
        {
          class: "bb-email",
          "data-bb-email": mailAttr.mailOption,
        },
        [
          emailHeader,
          parseEmailPerson(mailAttr.person),
          parseEmailSubject(mailAttr.subject),
          parseEmailContent(node.content),
          emailFooter,
        ]
      );
    };

    /**
    * @file Adds [newspaper] to bbcode
    * @example [newspaper]content[/newspaper]
    */
    const newspaper = (node) => {
        return toNode('div', { class: 'bb-newspaper' }, node.content);
    };

    /**
     * Disables line breaks for given content
     * @example
     * ```
     * [nobr]test
     * test
     * test
     * [/nobr]
     *
     * test test test
     * ```
     */
    const nobr = (node) => {
      return { disableLineBreakConversion: true, content: node.content };
    };

    /**
     * @file Adds [note] to bbcode
     * @example [note]content[/note]
     */

    const note = (node) => {
      return toNode("div", { class: "bb-note" }, [
        toNode("div", { class: "bb-note-tape" }, ""),
        toNode("div", { class: "bb-note-content" }, [
          node.content,
          toNode("div", { class: "bb-note-footer" }, ""),
        ]),
      ]);
    };

    const ooc = (node) => {
      return toNode(
        "div",
        {
          class: "bb-ooc",
        },
        node.content
      );
    };

    /**
    * @file Adds [pindent] to bbcode
    * @example [pindent]content[/pindent]
    */
    const pindent = (node) => {
        return toNode('span', { class: 'bb-pindent' }, node.content);
    };

    const side = (node) => {
      const attrs = preprocessAttr(node.attrs)._default || "left";
      return toNode("div", { class: "bb-side", "data-side": attrs }, node.content);
    };

    /**
     * Parses an inputted size value and returns the formatted valid font size
     * @param {string} fontValue the input of the size
     */
    function parseFontSize(fontValue) {
      let value;
      let fontSize = { valid: true };
      const parsedSize = /(\d+\.?\d?)(px|rem)?/i.exec(fontValue);
      const sizeRanges = {
        px_max: 36,
        px_min: 8,
        rem_max: 3,
        rem_min: 0.2,
        unitless_max: 7,
        unitless_min: 1,
      };

      if (parsedSize && (value = parsedSize[1])) {
        fontSize.unit = (parsedSize[2] || "").toLowerCase();
        switch (fontSize.unit) {
          case "px":
            if (value > sizeRanges.px_max) {
              value = sizeRanges.px_max;
            } else if (value < sizeRanges.px_min) {
              value = sizeRanges.px_min;
            }
            break;
          case "rem":
            if (value > sizeRanges.rem_max) {
              value = sizeRanges.rem_max;
            } else if (value < sizeRanges.rem_min) {
              value = sizeRanges.rem_min;
            }
            break;
          default:
            if ((fontSize.valid = fontValue.length === value.length)) {
              if (value > sizeRanges.unitless_max) {
                value = sizeRanges.unitless_max;
              } else if (value < sizeRanges.unitless_min) {
                value = sizeRanges.unitless_min;
              }
            }
            break;
        }

        fontSize.value = value;
      }
      return fontSize;
    }

    const size = (node) => {
      const input = preprocessAttr(node.attrs)._default;
      const fontSize = parseFontSize(input);
      if (!fontSize.valid) {
        return node.content;
      }
      let outputAttr = {};
      if (fontSize.unit) {
        outputAttr = { style: `font-size: ${fontSize.value}${fontSize.unit}` };
      } else {
        outputAttr = { "data-size": fontSize.value };
      }
      return toNode("span", outputAttr, node.content);
    };

    /**
     * @file Adds [spoiler] and [inlinespoiler] to bbcode
     *
     * Defaults to "Spoiler" name if no title provided
     *
     * @example `[spoiler=Title]text[/spoiler]`
     * @example `[inlinespoiler]hidden content[/inlinespoiler]
     */

    const spoiler = (node) => {
      const providedTitle = preprocessAttr(node.attrs)._default;
      const title = "Spoiler" + (providedTitle ? `: ${providedTitle}` : "");

      /**
       * <details class="bb-spoiler">
       *  <summary>Title</summary>
       *  <div class="bb-spoiler-content">
       *    lorem ipsum
       *  </div>
       * </details>
       */
      return {
        tag: "details",
        attrs: {
          class: "bb-spoiler",
        },
        content: [
          {
            tag: "summary",
            content: title,
          },
          {
            tag: "div",
            attrs: {
              class: "bb-spoiler-content",
            },
            content: node.content,
          },
        ],
      };
    };

    const inlinespoiler = (node) => {
      return toNode("span", { class: "bb-inline-spoiler" }, node.content);
    };
    
    const h = (node) => {
      return toNode("h1", {}, node.content);
    };
    
    const h1 = (node) => {
      return toNode( "h1", {}, node.content);
    };

    const h2 = (node) => {
      return toNode( "h2", {}, node.content);
    };

    const sh = (node) => {
      return toNode( "h2", {}, node.content);
    };

    const h3 = (node) => { 
      return toNode( "h3", {}, node.content);
    };

    const h4 = (node) => { 
      return toNode( "h4", {}, node.content);
    };

    const h5 = (node) => {
      return toNode( "h5", {}, node.content);
    };

    const h6 = (node) => {
      return toNode( "h6", {}, node.content);
    };

    const tags = {
      ...alignment,
      bg,
      border,
      check,
      color,
      divide,
      font,
      h,
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      highlight,
      inlinespoiler,
      justify,
      mail,
      newspaper,
      nobr,
      note,
      ooc,
      pindent,
      sh,
      side,
      size,
      spoiler,
    };

    const availableTags = Object.keys(tags);

    const preset = createPreset(tags);

    const N = '\n';
    const TAB = '\t';
    const EQ = '=';
    const QUOTEMARK = '"';
    const SPACE = ' ';
    const OPEN_BRAKET = '[';
    const CLOSE_BRAKET = ']';
    const SLASH = '/';
    const BACKSLASH = '\\';

    const isTagNode = (el)=>typeof el === 'object' && !!el.tag;
    const isStringNode = (el)=>typeof el === 'string';
    const isEOL = (el)=>el === N;
    const keysReduce = (obj, reduce, def)=>Object.keys(obj).reduce(reduce, def);
    const getNodeLength = (node)=>{
        if (isTagNode(node)) {
            return node.content.reduce((count, contentNode)=>count + getNodeLength(contentNode), 0);
        }
        if (isStringNode(node)) {
            return node.length;
        }
        return 0;
    };
    /**
     * Appends value to Tag Node
     * @param {TagNode} node
     * @param value
     */ const appendToNode = (node, value)=>{
        node.content.push(value);
    };
    /**
     * Replaces " to &qquot;
     * @param {String} value
     */ const escapeHTML = (value)=>value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;')// eslint-disable-next-line no-script-url
        .replace(/(javascript|data|vbscript):/gi, '$1%3A');
    /**
     * Acept name and value and return valid html5 attribute string
     * @param {String} name
     * @param {String} value
     * @return {string}
     */ const attrValue = (name, value)=>{
        const type = typeof value;
        const types = {
            boolean: ()=>value ? `${name}` : '',
            number: ()=>`${name}="${value}"`,
            string: ()=>`${name}="${escapeHTML(value)}"`,
            object: ()=>`${name}="${escapeHTML(JSON.stringify(value))}"`
        };
        return types[type] ? types[type]() : '';
    };
    /**
     * Transforms attrs to html params string
     * @param values
     */ const attrsToString = (values)=>{
        // To avoid some malformed attributes
        if (values == null) {
            return '';
        }
        return keysReduce(values, (arr, key)=>[
                ...arr,
                attrValue(key, values[key])
            ], [
            ''
        ]).join(' ');
    };
    /**
     * Gets value from
     * @example
     * getUniqAttr({ 'foo': true, 'bar': bar' }) => 'bar'
     * @param attrs
     * @returns {string}
     */ const getUniqAttr = (attrs)=>keysReduce(attrs, (res, key)=>attrs[key] === key ? attrs[key] : null, null);

    const getTagAttrs = (tag, params)=>{
        const uniqAattr = getUniqAttr(params);
        if (uniqAattr) {
            const tagAttr = attrValue(tag, uniqAattr);
            const attrs = {
                ...params
            };
            delete attrs[uniqAattr];
            const attrsStr = attrsToString(attrs);
            return `${tagAttr}${attrsStr}`;
        }
        return `${tag}${attrsToString(params)}`;
    };
    class TagNode {
        attr(name, value) {
            if (typeof value !== 'undefined') {
                this.attrs[name] = value;
            }
            return this.attrs[name];
        }
        append(value) {
            return appendToNode(this, value);
        }
        get length() {
            return getNodeLength(this);
        }
        toTagStart({ openTag =OPEN_BRAKET , closeTag =CLOSE_BRAKET  } = {}) {
            const tagAttrs = getTagAttrs(this.tag, this.attrs);
            return `${openTag}${tagAttrs}${closeTag}`;
        }
        toTagEnd({ openTag =OPEN_BRAKET , closeTag =CLOSE_BRAKET  } = {}) {
            return `${openTag}${SLASH}${this.tag}${closeTag}`;
        }
        toTagNode() {
            return new TagNode(this.tag.toLowerCase(), this.attrs, this.content);
        }
        toString({ openTag =OPEN_BRAKET , closeTag =CLOSE_BRAKET  } = {}) {
            const isEmpty = this.content.length === 0;
            const content = this.content.reduce((r, node)=>r + node.toString({
                    openTag,
                    closeTag
                }), '');
            const tagStart = this.toTagStart({
                openTag,
                closeTag
            });
            if (isEmpty) {
                return tagStart;
            }
            return `${tagStart}${content}${this.toTagEnd({
            openTag,
            closeTag
        })}`;
        }
        constructor(tag, attrs, content){
            this.tag = tag;
            this.attrs = attrs;
            this.content = Array.isArray(content) ? content : [
                content
            ];
        }
    }
    TagNode.create = (tag, attrs = {}, content = [])=>new TagNode(tag, attrs, content);
    TagNode.isOf = (node, type)=>node.tag === type;

    // type, value, line, row,
    const TOKEN_TYPE_ID = 'type'; // 0;
    const TOKEN_VALUE_ID = 'value'; // 1;
    const TOKEN_COLUMN_ID = 'row'; // 2;
    const TOKEN_LINE_ID = 'line'; // 3;
    const TOKEN_TYPE_WORD = 1; // 'word';
    const TOKEN_TYPE_TAG = 2; // 'tag';
    const TOKEN_TYPE_ATTR_NAME = 3; // 'attr-name';
    const TOKEN_TYPE_ATTR_VALUE = 4; // 'attr-value';
    const TOKEN_TYPE_SPACE = 5; // 'space';
    const TOKEN_TYPE_NEW_LINE = 6; // 'new-line';
    /**
     * @param {Token} token
     * @returns {string}
     */ const getTokenValue = (token)=>{
        if (token && typeof token[TOKEN_VALUE_ID] !== 'undefined') {
            return token[TOKEN_VALUE_ID];
        }
        return '';
    };
    /**
     * @param {Token}token
     * @returns {number}
     */ const getTokenLine = (token)=>token && token[TOKEN_LINE_ID] || 0;
    const getTokenColumn = (token)=>token && token[TOKEN_COLUMN_ID] || 0;
    /**
     * @param {Token} token
     * @returns {boolean}
     */ const isTextToken = (token)=>{
        if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {
            return token[TOKEN_TYPE_ID] === TOKEN_TYPE_SPACE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_NEW_LINE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_WORD;
        }
        return false;
    };
    /**
     * @param {Token} token
     * @returns {boolean}
     */ const isTagToken = (token)=>{
        if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {
            return token[TOKEN_TYPE_ID] === TOKEN_TYPE_TAG;
        }
        return false;
    };
    const isTagEnd = (token)=>getTokenValue(token).charCodeAt(0) === SLASH.charCodeAt(0);
    const isTagStart = (token)=>!isTagEnd(token);
    const isAttrNameToken = (token)=>{
        if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {
            return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_NAME;
        }
        return false;
    };
    /**
     * @param {Token} token
     * @returns {boolean}
     */ const isAttrValueToken = (token)=>{
        if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {
            return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_VALUE;
        }
        return false;
    };
    const getTagName = (token)=>{
        const value = getTokenValue(token);
        return isTagEnd(token) ? value.slice(1) : value;
    };
    const convertTagToText = (token)=>{
        let text = OPEN_BRAKET;
        text += getTokenValue(token);
        text += CLOSE_BRAKET;
        return text;
    };
    class Token {
        isEmpty() {
            // eslint-disable-next-line no-restricted-globals
            return isNaN(this[TOKEN_TYPE_ID]);
        }
        isText() {
            return isTextToken(this);
        }
        isTag() {
            return isTagToken(this);
        }
        isAttrName() {
            return isAttrNameToken(this);
        }
        isAttrValue() {
            return isAttrValueToken(this);
        }
        isStart() {
            return isTagStart(this);
        }
        isEnd() {
            return isTagEnd(this);
        }
        getName() {
            return getTagName(this);
        }
        getValue() {
            return getTokenValue(this);
        }
        getLine() {
            return getTokenLine(this);
        }
        getColumn() {
            return getTokenColumn(this);
        }
        toString() {
            return convertTagToText(this);
        }
        /**
       * @param {String} type
       * @param {String} value
       * @param line
       * @param row
       */ constructor(type, value, line, row){
            this[TOKEN_TYPE_ID] = Number(type);
            this[TOKEN_VALUE_ID] = String(value);
            this[TOKEN_LINE_ID] = Number(line);
            this[TOKEN_COLUMN_ID] = Number(row);
        }
    }
    const TYPE_WORD = TOKEN_TYPE_WORD;
    const TYPE_TAG = TOKEN_TYPE_TAG;
    const TYPE_ATTR_NAME = TOKEN_TYPE_ATTR_NAME;
    const TYPE_ATTR_VALUE = TOKEN_TYPE_ATTR_VALUE;
    const TYPE_SPACE = TOKEN_TYPE_SPACE;
    const TYPE_NEW_LINE = TOKEN_TYPE_NEW_LINE;

    function CharGrabber(source, options) {
        const cursor = {
            pos: 0,
            len: source.length
        };
        const substrUntilChar = (char)=>{
            const { pos  } = cursor;
            const idx = source.indexOf(char, pos);
            return idx >= 0 ? source.substring(pos, idx) : '';
        };
        const includes = (val)=>source.indexOf(val, cursor.pos) >= 0;
        const hasNext = ()=>cursor.len > cursor.pos;
        const isLast = ()=>cursor.pos === cursor.len;
        const skip = (num = 1, silent)=>{
            cursor.pos += num;
            if (options && options.onSkip && !silent) {
                options.onSkip();
            }
        };
        const rest = ()=>source.substring(cursor.pos);
        const grabN = (num = 0)=>source.substring(cursor.pos, cursor.pos + num);
        const curr = ()=>source[cursor.pos];
        const prev = ()=>{
            const prevPos = cursor.pos - 1;
            return typeof source[prevPos] !== 'undefined' ? source[prevPos] : null;
        };
        const next = ()=>{
            const nextPos = cursor.pos + 1;
            return nextPos <= source.length - 1 ? source[nextPos] : null;
        };
        const grabWhile = (cond, silent)=>{
            let start = 0;
            if (hasNext()) {
                start = cursor.pos;
                while(hasNext() && cond(curr())){
                    skip(1, silent);
                }
            }
            return source.substring(start, cursor.pos);
        };
        /**
       * @type {skip}
       */ this.skip = skip;
        /**
       * @returns {Boolean}
       */ this.hasNext = hasNext;
        /**
       * @returns {String}
       */ this.getCurr = curr;
        /**
       * @returns {String}
       */ this.getRest = rest;
        /**
       * @returns {String}
       */ this.getNext = next;
        /**
       * @returns {String}
       */ this.getPrev = prev;
        /**
       * @returns {Boolean}
       */ this.isLast = isLast;
        /**
       * @returns {Boolean}
       */ this.includes = includes;
        /**
       * @param {Function} cond
       * @param {Boolean} silent
       * @return {String}
       */ this.grabWhile = grabWhile;
        /**
       * @param {Number} num
       * @return {String}
       */ this.grabN = grabN;
        /**
       * Grabs rest of string until it find a char
       * @param {String} char
       * @return {String}
       */ this.substrUntilChar = substrUntilChar;
    }
    /**
     * Creates a grabber wrapper for source string, that helps to iterate over string char by char
     * @param {String} source
     * @param {Object} options
     * @param {Function} options.onSkip
     * @return CharGrabber
     */ const createCharGrabber = (source, options)=>new CharGrabber(source, options);
    /**
     * Trims string from start and end by char
     * @example
     *  trimChar('*hello*', '*') ==> 'hello'
     * @param {String} str
     * @param {String} charToRemove
     * @returns {String}
     */ const trimChar = (str, charToRemove)=>{
        while(str.charAt(0) === charToRemove){
            // eslint-disable-next-line no-param-reassign
            str = str.substring(1);
        }
        while(str.charAt(str.length - 1) === charToRemove){
            // eslint-disable-next-line no-param-reassign
            str = str.substring(0, str.length - 1);
        }
        return str;
    };
    /**
     * Unquotes \" to "
     * @param str
     * @return {String}
     */ const unquote = (str)=>str.replace(BACKSLASH + QUOTEMARK, QUOTEMARK);
    function NodeList(values = []) {
        const nodes = values;
        const getLast = ()=>Array.isArray(nodes) && nodes.length > 0 && typeof nodes[nodes.length - 1] !== 'undefined' ? nodes[nodes.length - 1] : null;
        const flushLast = ()=>nodes.length ? nodes.pop() : false;
        const push = (value)=>nodes.push(value);
        const toArray = ()=>nodes;
        this.push = push;
        this.toArray = toArray;
        this.getLast = getLast;
        this.flushLast = flushLast;
    }
    /**
     *
     * @param values
     * @return {NodeList}
     */ const createList = (values = [])=>new NodeList(values);

    // for cases <!-- -->
    const EM = '!';
    /**
     * Creates a Token entity class
     * @param {Number} type
     * @param {String} value
     * @param {Number} r line number
     * @param {Number} cl char number in line
     */ const createToken = (type, value, r = 0, cl = 0)=>new Token(type, value, r, cl);
    /**
     * @typedef {Object} Lexer
     * @property {Function} tokenize
     * @property {Function} isTokenNested
     */ /**
     * @param {String} buffer
     * @param {Object} options
     * @param {Function} options.onToken
     * @param {String} options.openTag
     * @param {String} options.closeTag
     * @param {Boolean} options.enableEscapeTags
     * @return {Lexer}
     */ function createLexer(buffer, options = {}) {
        const STATE_WORD = 0;
        const STATE_TAG = 1;
        const STATE_TAG_ATTRS = 2;
        const TAG_STATE_NAME = 0;
        const TAG_STATE_ATTR = 1;
        const TAG_STATE_VALUE = 2;
        let row = 0;
        let col = 0;
        let tokenIndex = -1;
        let stateMode = STATE_WORD;
        let tagMode = TAG_STATE_NAME;
        let contextFreeTag = '';
        const tokens = new Array(Math.floor(buffer.length));
        const openTag = options.openTag || OPEN_BRAKET;
        const closeTag = options.closeTag || CLOSE_BRAKET;
        const escapeTags = !!options.enableEscapeTags;
        const contextFreeTags = options.contextFreeTags || [];
        const onToken = options.onToken || (()=>{});
        const RESERVED_CHARS = [
            closeTag,
            openTag,
            QUOTEMARK,
            BACKSLASH,
            SPACE,
            TAB,
            EQ,
            N,
            EM
        ];
        const NOT_CHAR_TOKENS = [
            openTag,
            SPACE,
            TAB,
            N
        ];
        const WHITESPACES = [
            SPACE,
            TAB
        ];
        const SPECIAL_CHARS = [
            EQ,
            SPACE,
            TAB
        ];
        const isCharReserved = (char)=>RESERVED_CHARS.indexOf(char) >= 0;
        const isNewLine = (char)=>char === N;
        const isWhiteSpace = (char)=>WHITESPACES.indexOf(char) >= 0;
        const isCharToken = (char)=>NOT_CHAR_TOKENS.indexOf(char) === -1;
        const isSpecialChar = (char)=>SPECIAL_CHARS.indexOf(char) >= 0;
        const isEscapableChar = (char)=>char === openTag || char === closeTag || char === BACKSLASH;
        const isEscapeChar = (char)=>char === BACKSLASH;
        const onSkip = ()=>{
            col++;
        };
        const unq = (val)=>unquote(trimChar(val, QUOTEMARK));
        const checkContextFreeMode = (name, isClosingTag)=>{
            if (contextFreeTag !== '' && isClosingTag) {
                contextFreeTag = '';
            }
            if (contextFreeTag === '' && contextFreeTags.includes(name)) {
                contextFreeTag = name;
            }
        };
        const chars = createCharGrabber(buffer, {
            onSkip
        });
        /**
       * Emits newly created token to subscriber
       * @param {Number} type
       * @param {String} value
       */ function emitToken(type, value) {
            const token = createToken(type, value, row, col);
            onToken(token);
            tokenIndex += 1;
            tokens[tokenIndex] = token;
        }
        function nextTagState(tagChars, isSingleValueTag) {
            if (tagMode === TAG_STATE_ATTR) {
                const validAttrName = (char)=>!(char === EQ || isWhiteSpace(char));
                const name = tagChars.grabWhile(validAttrName);
                const isEnd = tagChars.isLast();
                const isValue = tagChars.getCurr() !== EQ;
                tagChars.skip();
                if (isEnd || isValue) {
                    emitToken(TYPE_ATTR_VALUE, unq(name));
                } else {
                    emitToken(TYPE_ATTR_NAME, name);
                }
                if (isEnd) {
                    return TAG_STATE_NAME;
                }
                if (isValue) {
                    return TAG_STATE_ATTR;
                }
                return TAG_STATE_VALUE;
            }
            if (tagMode === TAG_STATE_VALUE) {
                let stateSpecial = false;
                const validAttrValue = (char)=>{
                    // const isEQ = char === EQ;
                    const isQM = char === QUOTEMARK;
                    const prevChar = tagChars.getPrev();
                    const nextChar = tagChars.getNext();
                    const isPrevSLASH = prevChar === BACKSLASH;
                    const isNextEQ = nextChar === EQ;
                    const isWS = isWhiteSpace(char);
                    // const isPrevWS = isWhiteSpace(prevChar);
                    const isNextWS = isWhiteSpace(nextChar);
                    if (stateSpecial && isSpecialChar(char)) {
                        return true;
                    }
                    if (isQM && !isPrevSLASH) {
                        stateSpecial = !stateSpecial;
                        if (!stateSpecial && !(isNextEQ || isNextWS)) {
                            return false;
                        }
                    }
                    if (!isSingleValueTag) {
                        return isWS === false;
                    // return (isEQ || isWS) === false;
                    }
                    return true;
                };
                const name1 = tagChars.grabWhile(validAttrValue);
                tagChars.skip();
                emitToken(TYPE_ATTR_VALUE, unq(name1));
                if (tagChars.isLast()) {
                    return TAG_STATE_NAME;
                }
                return TAG_STATE_ATTR;
            }
            const validName = (char)=>!(char === EQ || isWhiteSpace(char) || tagChars.isLast());
            const name2 = tagChars.grabWhile(validName);
            emitToken(TYPE_TAG, name2);
            checkContextFreeMode(name2);
            tagChars.skip();
            // in cases when we has [url=someval]GET[/url] and we dont need to parse all
            if (isSingleValueTag) {
                return TAG_STATE_VALUE;
            }
            const hasEQ = tagChars.includes(EQ);
            return hasEQ ? TAG_STATE_ATTR : TAG_STATE_VALUE;
        }
        function stateTag() {
            const currChar = chars.getCurr();
            const nextChar = chars.getNext();
            chars.skip();
            // detect case where we have '[My word [tag][/tag]' or we have '[My last line word'
            const substr = chars.substrUntilChar(closeTag);
            const hasInvalidChars = substr.length === 0 || substr.indexOf(openTag) >= 0;
            if (isCharReserved(nextChar) || hasInvalidChars || chars.isLast()) {
                emitToken(TYPE_WORD, currChar);
                return STATE_WORD;
            }
            // [myTag   ]
            const isNoAttrsInTag = substr.indexOf(EQ) === -1;
            // [/myTag]
            const isClosingTag = substr[0] === SLASH;
            if (isNoAttrsInTag || isClosingTag) {
                const name = chars.grabWhile((char)=>char !== closeTag);
                chars.skip(); // skip closeTag
                emitToken(TYPE_TAG, name);
                checkContextFreeMode(name, isClosingTag);
                return STATE_WORD;
            }
            return STATE_TAG_ATTRS;
        }
        function stateAttrs() {
            const silent = true;
            const tagStr = chars.grabWhile((char)=>char !== closeTag, silent);
            const tagGrabber = createCharGrabber(tagStr, {
                onSkip
            });
            const hasSpace = tagGrabber.includes(SPACE);
            tagMode = TAG_STATE_NAME;
            while(tagGrabber.hasNext()){
                tagMode = nextTagState(tagGrabber, !hasSpace);
            }
            chars.skip(); // skip closeTag
            return STATE_WORD;
        }
        function stateWord() {
            if (isNewLine(chars.getCurr())) {
                emitToken(TYPE_NEW_LINE, chars.getCurr());
                chars.skip();
                col = 0;
                row++;
                return STATE_WORD;
            }
            if (isWhiteSpace(chars.getCurr())) {
                const word = chars.grabWhile(isWhiteSpace);
                emitToken(TYPE_SPACE, word);
                return STATE_WORD;
            }
            if (chars.getCurr() === openTag) {
                if (contextFreeTag) {
                    const fullTagLen = openTag.length + SLASH.length + contextFreeTag.length;
                    const fullTagName = `${openTag}${SLASH}${contextFreeTag}`;
                    const foundTag = chars.grabN(fullTagLen);
                    const isEndContextFreeMode = foundTag === fullTagName;
                    if (isEndContextFreeMode) {
                        return STATE_TAG;
                    }
                } else if (chars.includes(closeTag)) {
                    return STATE_TAG;
                }
                emitToken(TYPE_WORD, chars.getCurr());
                chars.skip();
                return STATE_WORD;
            }
            if (escapeTags) {
                if (isEscapeChar(chars.getCurr())) {
                    const currChar = chars.getCurr();
                    const nextChar = chars.getNext();
                    chars.skip(); // skip the \ without emitting anything
                    if (isEscapableChar(nextChar)) {
                        chars.skip(); // skip past the [, ] or \ as well
                        emitToken(TYPE_WORD, nextChar);
                        return STATE_WORD;
                    }
                    emitToken(TYPE_WORD, currChar);
                    return STATE_WORD;
                }
                const isChar = (char)=>isCharToken(char) && !isEscapeChar(char);
                const word1 = chars.grabWhile(isChar);
                emitToken(TYPE_WORD, word1);
                return STATE_WORD;
            }
            const word2 = chars.grabWhile(isCharToken);
            emitToken(TYPE_WORD, word2);
            return STATE_WORD;
        }
        function tokenize() {
            stateMode = STATE_WORD;
            while(chars.hasNext()){
                switch(stateMode){
                    case STATE_TAG:
                        stateMode = stateTag();
                        break;
                    case STATE_TAG_ATTRS:
                        stateMode = stateAttrs();
                        break;
                    case STATE_WORD:
                    default:
                        stateMode = stateWord();
                        break;
                }
            }
            tokens.length = tokenIndex + 1;
            return tokens;
        }
        function isTokenNested(token) {
            const value = openTag + SLASH + token.getValue();
            // potential bottleneck
            return buffer.indexOf(value) > -1;
        }
        return {
            tokenize,
            isTokenNested
        };
    }

    /**
     * @public
     * @param {string} input
     * @param {Object} opts
     * @param {Function} opts.createTokenizer
     * @param {Array<string>} opts.onlyAllowTags
     * @param {Array<string>} opts.contextFreeTags
     * @param {Boolean} opts.enableEscapeTags
     * @param {string} opts.openTag
     * @param {string} opts.closeTag
     * @return {Array<string|TagNode>}
     */ const parse = (input, opts = {})=>{
        const options = opts;
        const openTag = options.openTag || OPEN_BRAKET;
        const closeTag = options.closeTag || CLOSE_BRAKET;
        const onlyAllowTags = (options.onlyAllowTags || []).filter(Boolean).map((tag)=>tag.toLowerCase());
        let tokenizer = null;
        /**
       * Result AST of nodes
       * @private
       * @type {NodeList}
       */ const nodes = createList();
        /**
       * Temp buffer of nodes that's nested to another node
       * @private
       * @type {NodeList}
       */ const nestedNodes = createList();
        /**
       * Temp buffer of nodes [tag..]...[/tag]
       * @private
       * @type {NodeList}
       */ const tagNodes = createList();
        /**
       * Temp buffer of tag attributes
       * @private
       * @type {NodeList}
       */ const tagNodesAttrName = createList();
        /**
       * Cache for nested tags checks
       * @type Set<string>
       */ const nestedTagsMap = new Set();
        /**
       * @param {Token} token
       * @returns {boolean}
       */ const isTokenNested = (token)=>{
            const value = token.getValue();
            if (!nestedTagsMap.has(value) && tokenizer.isTokenNested && tokenizer.isTokenNested(token)) {
                nestedTagsMap.add(value);
                return true;
            }
            return nestedTagsMap.has(value);
        };
        /**
       * @private
       * @param {string} tagName
       * @returns {boolean}
       */ const isTagNested = (tagName)=>Boolean(nestedTagsMap.has(tagName));
        /**
       * @private
       * @param {string} value
       * @return {boolean}
       */ const isAllowedTag = (value)=>{
            if (onlyAllowTags.length) {
                return onlyAllowTags.indexOf(value.toLowerCase()) >= 0;
            }
            return true;
        };
        /**
       * Flushes temp tag nodes and its attributes buffers
       * @private
       * @return {Array}
       */ const flushTagNodes = ()=>{
            if (tagNodes.flushLast()) {
                tagNodesAttrName.flushLast();
            }
        };
        /**
       * @private
       * @return {Array}
       */ const getNodes = ()=>{
            const lastNestedNode = nestedNodes.getLast();
            if (lastNestedNode && Array.isArray(lastNestedNode.content)) {
                return lastNestedNode.content;
            }
            return nodes.toArray();
        };
        /**
       * @private
       * @param {string|TagNode} node
       * @param {boolean} isNested
       */ const appendNodeAsString = (node, isNested = true)=>{
            const items = getNodes();
            if (Array.isArray(items)) {
                items.push(node.toTagStart({
                    openTag,
                    closeTag
                }));
                if (node.content.length) {
                    node.content.forEach((item)=>{
                        items.push(item);
                    });
                    if (isNested) {
                        items.push(node.toTagEnd({
                            openTag,
                            closeTag
                        }));
                    }
                }
            }
        };
        /**
       * @private
       * @param {string|TagNode} node
       */ const appendNodes = (node)=>{
            const items = getNodes();
            if (Array.isArray(items)) {
                if (isTagNode(node)) {
                    if (isAllowedTag(node.tag)) {
                        items.push(node.toTagNode());
                    } else {
                        appendNodeAsString(node);
                    }
                } else {
                    items.push(node);
                }
            }
        };
        /**
       * @private
       * @param {Token} token
       */ const handleTagStart = (token)=>{
            flushTagNodes();
            const tagNode = TagNode.create(token.getValue());
            const isNested = isTokenNested(token);
            tagNodes.push(tagNode);
            if (isNested) {
                nestedNodes.push(tagNode);
            } else {
                appendNodes(tagNode);
            }
        };
        /**
       * @private
       * @param {Token} token
       */ const handleTagEnd = (token)=>{
            flushTagNodes();
            const lastNestedNode = nestedNodes.flushLast();
            if (lastNestedNode) {
                appendNodes(lastNestedNode);
            } else if (typeof options.onError === 'function') {
                const tag = token.getValue();
                const line = token.getLine();
                const column = token.getColumn();
                options.onError({
                    message: `Inconsistent tag '${tag}' on line ${line} and column ${column}`,
                    tagName: tag,
                    lineNumber: line,
                    columnNumber: column
                });
            }
        };
        /**
       * @private
       * @param {Token} token
       */ const handleTag = (token)=>{
            // [tag]
            if (token.isStart()) {
                handleTagStart(token);
            }
            // [/tag]
            if (token.isEnd()) {
                handleTagEnd(token);
            }
        };
        /**
       * @private
       * @param {Token} token
       */ const handleNode = (token)=>{
            /**
         * @type {TagNode}
         */ const lastTagNode = tagNodes.getLast();
            const tokenValue = token.getValue();
            const isNested = isTagNested(token);
            if (lastTagNode) {
                if (token.isAttrName()) {
                    tagNodesAttrName.push(tokenValue);
                    lastTagNode.attr(tagNodesAttrName.getLast(), '');
                } else if (token.isAttrValue()) {
                    const attrName = tagNodesAttrName.getLast();
                    if (attrName) {
                        lastTagNode.attr(attrName, tokenValue);
                        tagNodesAttrName.flushLast();
                    } else {
                        lastTagNode.attr(tokenValue, tokenValue);
                    }
                } else if (token.isText()) {
                    if (isNested) {
                        lastTagNode.append(tokenValue);
                    } else {
                        appendNodes(tokenValue);
                    }
                } else if (token.isTag()) {
                    // if tag is not allowed, just past it as is
                    appendNodes(token.toString());
                }
            } else if (token.isText()) {
                appendNodes(tokenValue);
            } else if (token.isTag()) {
                // if tag is not allowed, just past it as is
                appendNodes(token.toString());
            }
        };
        /**
       * @private
       * @param {Token} token
       */ const onToken = (token)=>{
            if (token.isTag()) {
                handleTag(token);
            } else {
                handleNode(token);
            }
        };
        tokenizer = (opts.createTokenizer ? opts.createTokenizer : createLexer)(input, {
            onToken,
            openTag,
            closeTag,
            onlyAllowTags: options.onlyAllowTags,
            contextFreeTags: options.contextFreeTags,
            enableEscapeTags: options.enableEscapeTags
        });
        // eslint-disable-next-line no-unused-vars
        tokenizer.tokenize();
        // handles situations where we open tag, but forgot close them
        // for ex [q]test[/q][u]some[/u][q]some [u]some[/u] // forgot to close [/q]
        // so we need to flush nested content to nodes array
        const lastNestedNode = nestedNodes.flushLast();
        if (lastNestedNode && isTagNested(lastNestedNode.tag)) {
            appendNodeAsString(lastNestedNode, false);
        }
        return nodes.toArray();
    };

    /* eslint-disable no-plusplus */ const isObj$2 = (value)=>typeof value === 'object';
    const isBool = (value)=>typeof value === 'boolean';
    function iterate(t, cb) {
        const tree = t;
        if (Array.isArray(tree)) {
            for(let idx = 0; idx < tree.length; idx++){
                tree[idx] = iterate(cb(tree[idx]), cb);
            }
        } else if (tree && isObj$2(tree) && tree.content) {
            iterate(tree.content, cb);
        }
        return tree;
    }
    function same(expected, actual) {
        if (typeof expected !== typeof actual) {
            return false;
        }
        if (!isObj$2(expected) || expected === null) {
            return expected === actual;
        }
        if (Array.isArray(expected)) {
            return expected.every((exp)=>[].some.call(actual, (act)=>same(exp, act)));
        }
        return Object.keys(expected).every((key)=>{
            const ao = actual[key];
            const eo = expected[key];
            if (isObj$2(eo) && eo !== null && ao !== null) {
                return same(eo, ao);
            }
            if (isBool(eo)) {
                return eo !== (ao === null);
            }
            return ao === eo;
        });
    }
    function match(expression, cb) {
        return Array.isArray(expression) ? iterate(this, (node)=>{
            for(let idx = 0; idx < expression.length; idx++){
                if (same(expression[idx], node)) {
                    return cb(node);
                }
            }
            return node;
        }) : iterate(this, (node)=>same(expression, node) ? cb(node) : node);
    }

    function walk$2(cb) {
        return iterate(this, cb);
    }
    function bbob(plugs) {
        const plugins = typeof plugs === 'function' ? [
            plugs
        ] : plugs || [];
        let options = {
            skipParse: false
        };
        return {
            process (input, opts) {
                options = opts || {};
                const parseFn = options.parser || parse;
                const renderFn = options.render;
                const data = options.data || null;
                if (typeof parseFn !== 'function') {
                    throw new Error('"parser" is not a function, please pass to "process(input, { parser })" right function');
                }
                let tree = options.skipParse ? input || [] : parseFn(input, options);
                // raw tree before modification with plugins
                const raw = tree;
                tree.messages = [];
                tree.options = options;
                tree.walk = walk$2;
                tree.match = match;
                plugins.forEach((plugin)=>{
                    tree = plugin(tree, {
                        parse: parseFn,
                        render: renderFn,
                        iterate,
                        match,
                        data
                    }) || tree;
                });
                return {
                    get html () {
                        if (typeof renderFn !== 'function') {
                            throw new Error('"render" function not defined, please pass to "process(input, { render })"');
                        }
                        return renderFn(tree, tree.options);
                    },
                    tree,
                    raw,
                    messages: tree.messages
                };
            }
        };
    }

    const SELFCLOSE_END_TAG = '/>';
    const CLOSE_START_TAG = '</';
    const START_TAG = '<';
    const END_TAG = '>';
    const renderNode = (node, { stripTags =false  })=>{
        if (!node) return '';
        const type = typeof node;
        if (type === 'string' || type === 'number') {
            return node;
        }
        if (type === 'object') {
            if (stripTags === true) {
                // eslint-disable-next-line no-use-before-define
                return renderNodes(node.content, {
                    stripTags
                });
            }
            if (node.content === null) {
                return [
                    START_TAG,
                    node.tag,
                    attrsToString(node.attrs),
                    SELFCLOSE_END_TAG
                ].join('');
            }
            // eslint-disable-next-line no-use-before-define
            return [
                START_TAG,
                node.tag,
                attrsToString(node.attrs),
                END_TAG,
                renderNodes(node.content),
                CLOSE_START_TAG,
                node.tag,
                END_TAG
            ].join('');
        }
        if (Array.isArray(node)) {
            // eslint-disable-next-line no-use-before-define
            return renderNodes(node, {
                stripTags
            });
        }
        return '';
    };
    const renderNodes = (nodes, { stripTags =false  } = {})=>[].concat(nodes).reduce((r, node)=>r + renderNode(node, {
                stripTags
            }), '');
    const render = renderNodes;

    /**
     * Plugin that converts consecutive normal spaces (U+0020) to non-breaking spaces (U+00A0).
     * To use, put as function similar to the presets.
     *
     *
     * @example
     * ```ts
     * const output = bbob([preset(), , preserveWhitespace(), lineBreakPlugin()]).process(input, {render}).html
     * ```
     */

    /**
     * Checks if input is an object
     * @param value input
     * @returns if value is an object
     */
    const isObj$1 = (value) => typeof value === "object";

    /**
     * Walks the tree of nodes. Checks for node of consecutive spaces. If found replaces every space in
     * node with a nonbreaking space.
     * Preserves multiple spaces so html won't truncate them.
     *
     * Walks through entire tree.
     * @param t tree of nodes to be processed
     * @returns modified tree
     */
    const walk$1 = (t) => {
      const tree = t;

      if (Array.isArray(tree)) {
        for (let idx = 0; idx < tree.length; idx++) {
          const child = walk$1(tree[idx]);
          if (Array.isArray(child)) {
            tree.splice(idx, 1, ...child);
            idx += child.length - 1;
          } else {
            tree[idx] = child;
          }
        }
      } else if (tree && isObj$1(tree) && tree.content) {

        walk$1(tree.content);
      }

      //Bbob breaks up nodes by the presence of normal spaces.
      //So a node with a normal space can only have normal spaces in that node.
      if (isStringNode(tree)) {
        if(tree.length > 1 && tree[0] === " ") {
          let numSpaces = tree.length;
          return [String.fromCharCode(160).repeat(numSpaces)];
        }
      }

      return tree;
    };

    /**
     * Converts consecutive normal spaces (U+0020) to nonbreaking spaces (U+00A0).
     * Supply this as a plugin in the preset lists.
     *
     * @example converts consecutive normal spaces (U+0020) to nonbreaking spaces (U+00A0)
     * ```ts
     * const output = bbob([preset(), preserveWhitespace(), lineBreakPlugin()]).process(input, {render}).html
     * ```
     *
     * @returns plugin to be used in BBob process
     */
    const preserveWhitespace = () => {
      return (tree) => walk$1(tree);
    };

    /**
     * Plugin that converts line breaks to `<br/>` tags.
     * To use, put as function similar to the presets.
     *
     * If a node is marked with `noLineBreakConversion`, then it'll skip the parsing the children
     *
     * @example
     * ```ts
     * const output = bbob([preset(), lineBreakPlugin()]).process(input, {render}).html
     * ```
     */

    /**
     * Checks if input is an object
     * @param value input
     * @returns if value is an object
     */
    const isObj = (value) => typeof value === "object";

    /**
     * Walks the tree of nodes. Will add `br` tag to all `\n` in format that can be used in any renderer.
     * Preserves \n so that markdown-it doesn't try to treat everything like a block
     *
     * If a node has the property noLineBreakConversion is encountered, will skip parsing children.
     * @param t tree of nodes to be processed
     * @returns modified tree
     */
    const walk = (t) => {
      const tree = t;

      if (Array.isArray(tree)) {
        for (let idx = 0; idx < tree.length; idx++) {
          const child = walk(tree[idx]);
          if (Array.isArray(child)) {
            tree.splice(idx, 1, ...child);
            idx += child.length - 1;
          } else {
            tree[idx] = child;
          }
        }
      } else if (tree && isObj(tree) && tree.content) {
        if (tree.disableLineBreakConversion) {
          // stop walk. children won't be parsed to have <br>
          return tree.tag ? tree : tree.content;
        }
        walk(tree.content);
      }

      if (isEOL(tree)) {
        return [{ tag: "br", content: null }, "\n"];
      }

      return tree;
    };

    /**
     * Converts `\n` to `<br/>` self closing tag. Supply this as the last plugin in the preset lists
     *
     * @example converts all line breaks to br
     * ```ts
     * const output = bbob([preset(), lineBreakPlugin()]).process(input, {render}).html
     * ```
     * @example will not convert line breaks inside [nobr]
     * ```ts
     * const nobr = (node: TagNode) => {return { disableLineBreakConversion: true, content: node.content }}; \\ tag in preset
     * ...
     * const output = bbob([preset(), lineBreakPlugin()]).process(input, {render}).html
     * ```
     * @returns plugin to be used in BBob process
     */
    const lineBreakPlugin = () => {
      return (tree) => walk(tree);
    };

    // TODO: Change error handling so active editing doesn't spam the console
    const options = {
      onlyAllowTags: [...availableTags, "nobr"],
      enableEscapeTags: true,
      onError: (err) =>
        // eslint-disable-next-line no-console
        console.warn(err.message, err.lineNumber, err.columnNumber),
    };

    const RpNBBCode = (code, opts) => {
      const plugins = [preset()];
      if (opts.preserveWhitespace) {
        plugins.push(preserveWhitespace());
      }
      plugins.push(lineBreakPlugin());
      return bbob(plugins).process(code, {
        render,
        ...options,
        data: {
          fonts: new Set(),
        },
      });
    };

    exports.RpNBBCode = RpNBBCode;

}));
